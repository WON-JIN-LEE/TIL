# 항해99 4주차 회고록
## What I Do
- 자료구조 스택, 큐, 해시테이블 정리
- 버블, 선택, 삽입, 퀵, 머지, 힙 Sort 정리 후 포스팅
- 파이썬 답게 강의 듣기
- 이진탐색 공부, 문제 풀이
- Git 강의 - fork사용, PR보내기, Git 원격과 로컬 동기화하기

## What I Learned and will
- 쿠키, 세션, 캐쉬, JWT 학습
- DB Index 공부
- 파이썬 답게 강의 듣기
- 필요한 Git강의 듣고 적용하기
- 트리, 이진탐색 공부 후 정리
- 웹 스크래핑 셀레니움 사용해보기

---

## 버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬

### 버블 정렬 (bubble Sort)
버블 정렬은 뒤에서 부터 앞으로 정렬을 진행하는 구조를 가지고 있다.
오름차순 정렬 기준으로 배열의 맨 뒷공간에 가장 높은 값을 보내고, 그앞에 두번째로 큰 값을 보낸다.
그래서 배열 내 값들을 앞뒤로 서로 비교하며 자리를 바꾸는 작업르 반복한다.

- 버블 정령은 큰 값들을 뒤에서부터 앞으로 하나씩 쌓아 나가기 때문에 원소가 자리를 잡을때 마다 정렬의 범위가 하니씩 줄어들게 도니다.
- 제일 작은 값을 찾아 맨 앞에 위치시키는 선택정렬과는 반대의 정렬 방향을 갖는다.
- 다른 정렬 알고리즘에 비하여 값의 swap이 비번하게 일어난다.
- O(n^2)의 시간 복잡도를 갖는다. 루프문을 통해 모든 인덱스에 방문해야 하므로 O(N)의 시간이 소모되고 또 인접한 원소와 대소 비교 및 swap을 위하여 O(N)의 시간이 추가로 필요하기 때문이다

### 선택 정렬 (selection Sort)
선택 정렬 알고리즘은 데이터중 가장 작은 데이터를 선택하여 맨 앞부터 순서대로 정렬해가는 알고리즘이다.
따라서 뒤 인덱스로 갈수록 비교 범위가 1씩 감소한다는 특징을 갖는다.

- 입력된 배열에 상관없이 동일한 연산량을 갖기 때문에 최적화의 역지가 적어 성능이 떨어지는 편이다.
- 오름차순 정렬 기준으로 최소값을 찾기 위해 비교는 여러번 하지만 스왑은 딱 한번만 일어난다. 따라서 시간복잡도는 O(n^2)을 갖는다.
- 이러한 성능 상의 한계 떄문에 실제로는 잘 쓰이진 않지만, 가장 구현이 쉬운 정렬 알고리즘이다.

### 삽입 정렬 (insertion Sort)
삽입 정렬이란 모든 요소를 앞에서부터 정렬 범위를 확장시켜나가며 정렬을 진행한다. 차례대로 이미 정렬된 배열 부분과 확장된 범위 부분을 비교하며, 자신의 위치를 찾아 삽입함으로써 정렬을 완성시키는 알고리즘이다.

- 정렬이 진행될수록 범위가 넓어진다. outer루프는 순방향, inner루프는 역방향으로 반복을 진행한다.
- 루프문을 통해 정렬 범위를 2개로 시작하여 전체로 확장해 나아가기 떄문에 기본적으로 O(N)이 소모되며, 각 회차마다 정렬 범위에 추가된 값과 기존 값들과의 대소 비교 및 스왑을 위해 O(N)이 추가적으로 소모된다.
- 따라서 삽입 정렬은 O(N^2)의 시간 복잡도를 가지는 정렬 알고리즘이다.


### 퀵 정렬 (quick sort)
퀵 정렬은 분할 정복 기법과 재취 알고리즘을 이용한 정렬 알고리즘이다. pivot이 되입되었다. pivot이란 정렬을 위해 사용하는 임의의 기준값이다.

- 퀵 정렬의 성능은 pivot값의 선택에 따라 크게 달라질 수 있다.
- 이상적인 경우, 작은 값과 큰값이 동일한 개수로 분할된다면, O(NlogN)의 시간복잡도를 갖게된다.
- 하지만 이미 정렬되어 pivot기준으로 값이 한쪽으로 치우치게 된다면 O(N^2)의 시간복잡도를 갖게된다.


### 병합 정렬 (merge sort)
병합 정렬은 퀵 정렬과 동일하게 분할 정복 기봅과 재귀 알고리즘을 이용한 정렬 알고리즘이다. 주어진 배열의 크기가 1이 될 때 까지 반씩 쪼갠뒤 정렬을 진행하며 병합을 진행한다.

- 병합 정렬은 크게 split 단계와 merge단계로 나눌 수 있으며, 단순히 중간 인덱스를 찾아야 하는 분할 비용보다 모든 값들을 비교해야 하는 병합 비용이 더욱 크다.
- 기본 배열을 분할할때 반복의 수가 거듭할수록 반으로 줄어들기 때문에 O(logN)의 시간이 필요하며, 병합시 모든 값들을 비교해야 하므로 O(N)시간이 소모된다. 
- 따라서 병합 정렬은 O(NlogN)의 시간복잡도를 갖는다.


### 힙 정렬 (heap Sort)
최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법이다. 정렬해야 할 n개의 요소들로 최대, 최소 힙을 만든다. 그 다음으로 한 번에 하나씩 요소를 힙으로 꺼내서 배열에 추가한다.

최대 힙으로 만들어 정렬하면 내림차순이 되고, 최소 힙으로 정렬하면 오름차순이 된다. reverse같은 메서드를 사용하면 최대 힙으로도 오름차순으로 정렬 가능하다.

- 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.
- 힙 트리의 전체 높이가 logN(완전 이진 트리)이므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 logN 만큼 소요된다.
- 힙 정렬은 요소의 개수가 n개 일때 전체적으로 O(NlogN)의 시간 복잡도를 갖게된다.

---

### 마치며

항해 3주차를 보냈다. 꾸준히 알고리즘을 구현해보고 정리하고 있다. 파이썬 여러 메서드들을 사용해보려 한다. 이진탐색 문제를 계속 풀고 있는데 문제 요점만 잘 찾으면 이진탐색을 적용해 구현할 수 있을 것 같다. 그래프 자료구조 DFS, BFS는 이론은 이해했지만 구현을 하는게 쉽지 않았다. 다시 그래프 공부하면서 하나씩 정리해야겠다.